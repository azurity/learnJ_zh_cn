# 第四章：脚本和显式函数 

所谓的脚本(script)，就是一组连续的多行J语言代码。本章的主题就是脚本，在脚本中定义函数，在文件中的脚本。

## 4.1 文本
下面是对变量`txt`的赋值：

```
    txt =: 0 : 0
What is called a "script" is
a sequence of lines of J.
)
```

表达式`0 : 0`表示“如下(as follows)”。也就是说，`0 : 0`是一个动词，可以获取他的参数病作为其结果。这个参数是指从它开始，直到以单独的右括号开头的一行为止，其间的内容。
 
`txt`的值就是在单个字符串中的两行文字。这个字符串中包含折行符(`LF`)，可以让`txt`显示为多行。`txt`有着其一定的长度，阶数是1，是一个列表，包含了两个折行符。

``` 
    txt
What is called a "script" is
a sequence of lines of J.
```

`$ txt`|`# $ txt`|`+/ txt = LF`
-------|---------|---
`55`   |`1`      |`2`
 
我们称`txt`是一个“文本”变量，是一个有着零或更多个折行符的字符串。

## 4.2 脚本程序

我们来看如何用分步形式来描述计算过程。下面是例子。华氏到摄氏度的转换可以分为两个步骤。给定华氏度`T`：

```
    T =: 212
```

第一步是减32.把结果命名为`t`：

```
    t =: T - 32
```

第二步是把`t`乘以`5%9`以求得摄氏度。

```
    t * 5 % 9
100
```

假设我们要用不同的`T`来做几次这个计算。我们可以用脚本来记录这两行程序来实现重复利用的效果。脚本由存储在一个文本变量中的多行J语言代码组成： 

```
    script =: 0 : 0
t =: T - 32
t * 5 % 9
)
```

这样的脚本可以被一个J语言内置动词执行，这个动词的表达式是`0 !: 1`我们可以称其为`do`。

```
    do =: 0 !: 1
```

这个表达式`0 !: 1`可以被理解为用左参数`0`和右参数`1`作用于连词`!:`(感叹号 冒号，称为“外置连词”)产生的动词。`!:`以成组的动词的形式，提供了一些使用功能或系统服务。更多相关内容，详见[此处](http://www.jsoftware.com/help/dictionary/xmain.htm)的字典。

在这个例子里，左参数`0`指定了脚本执行组，右参数`1`选定组中的一个成员。这个成员是一个动词。这个动词会执行整个脚本，忽视错误，并将每一步显示在屏幕上。

如果输入`do script`，将会看到几行代码，就如同直接从键盘输入的那样：

```
    do script
    t =: T - 32
    t * 5 % 9
100
```

我们可以使用不同的`T`，载运行一次脚本。

```
    T =: 32
    do script
    t =: T - 32
    t * 5 % 9
0
```

## 4.3 显式定义函数

函数也可以用脚本直接定义。下面是关于华氏转摄氏度的动词的例子。 

```
    Celsius =: 3 : 0
t =: y - 32
t * 5 % 9
)
```

`Celsius 32 212`|`1 + Celsius 32 212`
----------------|---
`0 100`         |`1 101`
 
接下来是这种定义的主要部分的解释：

### 4.3.1 定义头(Heading)

函数用表达式`3 : 0`开头。意思是“一个如下的动词”。（与之相比，`0 : 0`表示“一个如下的字符串”）`3 : 0`中的冒号是一个连词。其左参数(`3`)表示“动词”，右参数(`0`)表示“内容如下”。更多相关内容，详见[第十二章](chapter12.md)。函数的这种定义方式被叫做“显式定义”，或简称为“显式”。

### 4.3.2 意图(Meaning)

表达式`Celsius 32 212`将动词`Celsius`应用了参数`32 212`，其方式是执行一个描述（或模拟）为如下形式的计算：

```
    y =: 32 212
    t =: y - 32
    t * 5 % 9
0 100
```

注意，在第一行之后，计算将根据脚本内容进行。 

### 4.3.3 参数变量(Argument Variable)

参数的值(`32 212`)作为一个叫做`y`的变量传递给脚本。这种“参数变量”在单目函数中被命名为`y`。（在接下来的双目函数中，左参数被命名为`x`右参数被命名为`y`）

### 4.3.4 局部变量(Local Variables)

这是`Celsius`的定义：

```
    Celsius =: 3 : 0
t =: y - 32
t * 5 % 9
)
```

可以看到，这包含了一个给变量`t`的赋值。这个变量仅在执行`Celsius`时可以使用。不幸的是，每当我们使用这个函数，这个对`t`的赋值会对其他也叫`t`，但定义在`Celsius`之外的变量产生干扰。下面是一个对此事验证：

```
    t =: 'hello' 

    Celsius 212
100

    t
180
```

我们看到变量`t`的原始值(`'hello'`)在执行`Celsius`之后已经被改变。为了避免这种影响，我们应当表明`t`是`Celsius`中的私有内容，用以和其他叫做`t`的变量区分开。

为了这个目的，有一种特殊的赋值形式，使用符号`=.`(等号 点)。修订版本如下：

```
    Celsius =: 3 : 0
t =. y - 32
t * 5 % 9
)
```

我们称`Celsius`中的`t`是局部变量， 或者`t`在`Celsius`内部。相比之下，定义在函数外的变量称之为全局的(global)。我们可以证实，在`Celsius`中对于局部变量`t`得赋值不会影响到全局变量`t`

```
    t =: 'hello'

    Celsius 212
100

    t
hello
```

参数变量`y`也是一个全局变量。因此计算`(Celsius 32 212)`可以更准确的被如下计算模拟：

```
    y =. 32 212
    t =. y - 32
    t * 5 % 9
0 100
```

### 4.3.5 双目动词(Dyadic Verbs)

`Celsius`是一个单目动词，由`3 : 0`引导，并定义为接受一个参数`y`。相比之下，一个双目动词用`4 : 0`引导。左参数和右参数分别被命名为`x`和`y`。接下来是一个例子。两个数的“正差值”是大的数减小的数。

```
posdiff =: 4 : 0
larger =. x >. y
smaller =. x <. y
larger - smaller
)
```

`3 posdiff 4`|`4 posdiff 3`
-------------|---
`1`          |`1`

### 4.3.6 单行形式(One-Liners)
一个单行形式的脚本可以写成一个字符串，作为冒号连词的由参数给出。

```
    PosDiff =: 4 : '(x >. y) - (x <. y)'
    4 PosDiff 3
1
```

### 4.3.7 控制结构(Control Structures)
到目前为止，我们看到的所有用脚本定义的函数，都是从第一行开始，依次执行每一行，直到最后一行为止。

顺序执行并不是唯一可能的执行路线。可以选择接下来要执行的表达式。

例如，这是一个根据长宽高计算体积的函数。函数将会检查它的参数是否是一个三项的列表（长宽高）。如果是就计算体积，不是的话，其结果就是字符串`'ERROR'`。

```
    volume =: 3 : 0
if. 3 = # y
do. * / y
else. 'ERROR'
end.
)
```

我们可以看到：

`volume 2 3 4`|`volume 2 3`
--------------|---
`24`          |`ERROR`

从`if.`到`end.`的所有内容，组成了所谓的“控制结构”。这里的`if.` `do.` `else.`和`end.`被叫做“控制字”。更多关于控制结构的内容，详见[第十二章](chapter12.md)。

## 4.4 隐式定义和显式定义对比

我们已经看到了两种不同风格的函数定义方式。本章中介绍的显式方式，之所以这么称呼，是因为其明确的指出了参数变量。在上面的`volume`中，变量`y`是对参数的显式引用。

相比之下，上一章中提到的风格被叫做“隐式”，因为其并没有明确提到参数变量。例如，对比正差值函数的显式定义与隐式定义：

```
    epd =: 4 : '(x >. y) - (x <. y)'

    tpd =: >. - <.
```

许多隐式定义的函数可以显式定义，反之亦然。选择何种风格主要取决于哪种看起来更加自然，也取决于我们是如何构思函数定义的。这个选择基于两种分解问题的方式，一种是分解为脚本化的步骤，另一种是分解成更小的函数。

隐式风格允许更紧凑的定义。因为这个原因，隐式函数更适合系统性分析和转化。事实上，对于大部分的隐式函数，J语言系统可以自动转换出逆函数和派生物。

## 4.5 函数的值

函数也是值，其值可以被通过输入表达式得方式来显式。表达式就像名称一样的简单。接下来是一些隐式或显式函数的值。

```
    -& 32
+-+-+--+
|-|&|32|
+-+-+--+

    epd
+-+-+-------------------+
|4|:|(x >. y) - (x <. y)|
+-+-+-------------------+

    Celsius
+-+-+-----------+
|3|:|t =. y - 32|
| | |t * 5 % 9 |
+-+-+-----------+
```

在此，每一个函数的值被表示为一个箱结构。这是默认方式，也可以选择其它的显式方式，详见[第二十七章](chapter27.md)。现在我们只会提及“线性表述”，其显示为一个字符序列，可以被再次输入来生成函数。可以通过输入如下内容，来切换值线性表述方式：

```
(9!:3) 5
```

接下来是例子：

```
    epd
4 : '(x >. y) - (x <. y)'
```

在接下来的章节，函数的值通常被显示为线性表述方式。

## 4.6 脚本文件
我们已经看到了脚本（多行的J语言代码），用于定义了单个变量：文本变量和函数。一个保存了多行J语言代码的文本文件，可以存有许多定义。这样的文件被称为脚本文件，其实用性在于，读取一个文件，其中的所有定义均会被执行。
下面是一个例子，使用某个文本编辑器，在电脑上创建一个文件，包含如下两行文本。

```
squareroot =: %:
 z =: 1 , (2+2) , (4+5)
```

按照约定，J语言脚本文件的文件名结尾是`.ijs`。假设已经创建了一个文件（在windows上），其全路径是`c:\temp\myscript.ijs`。

然后，在J语言交互界面（J语言会话，J session）中，定义一个变量`F`来存储文件名字符串，以便于后续操作。

```
    F =: 'c:\temp\myscript.ijs' 
```

创建完这个两行的脚本文件之后，我们可以输入如下内容来执行：

```
    0!:1 < F
```

我们可以看到屏幕上的多行代码，就和从键盘输入的一样。 

```
    squareroot =: %:
    z =: 1 ,(2+2), (4+5)
```

接下来我们可以使用从文件中载入的定义进行运算。

```
    z
1 4 9

    squareroot z
1 2 3
```

在J会话的通常活动是编辑，加载，重新加载脚本文件中的定义以及由键盘输入来启动运算。在会话间传递的仅仅是脚本文件。J语言系统上其余诸如状态存储之类的内容，会在会话结束后消失，在会话中输入的所有定义也会消失。因此在关闭会话前，请确认所有脚本文件都是最新的，并且它包含了你所希望保留的定义。

在会话开始时，J语言系统会自动加载一个指定的脚本文件，称之为“概要文件(profile)”。 (更多相关内容详见[第二十六章](chapter26.md))这个文件可以编辑，是一个记录你认为有用定义的好地方。

我们已经到达第四章的结尾，这也是第一部分的结尾。接下来的章节将会更加深入和详细的探讨我们在第一部分所提及的主题。
